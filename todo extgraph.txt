Roadmap after Beta 4 (more or less sorted):

X* Optimization of TestCollide.

0* add pixel collide.
/* More routines related to planes: OrageGL's, Jesse's, etc.

0* tilemap engine: make it usable with doublebuffering, in some way. -> Grib !

/* Fix bugs (pixel macros - Kevin ?, SpriteX8Get, etc.), update documentation (update
links, check prototypes, document new functions, etc.) and header...

/* "Fast" scaling 240x128 -> 160x85, 160x85 -> 240x128, 1 plane. Is there actually a point in making 2-plane versions ?
It may or may not help the plane switching. There's no significant difference speed-wise with 1-plane versions,
the 2-plane versions can increase memory consumption since reusing the same buffer is impossible.
These routines are very expensive speed-wise and size-wise, their effect is visually rather poor (especially
reduction - strings get ugly). It's IMO a major mistake designing a program only for one type and scaling the graphics.

/* Generic font routines, OS or custom. Two sets of pointers, one should always contain the OS fonts (i.e., mandatory
SetupCharSet).

/* fastsrb:
    0* Macros for Put with callback, to make programmers' life a bit easier.
    0* Make clipped routines.
    0* demo23: grayscale fastsrb. Simplified Phoenix Platinum / Krypton / Venus. 10 16x16 ships (of which 2 overlap)
drawn with clipped routines, in TRANW mode, over a background that scrolls very often (every or every other AI5 tick).
Redraw each frame if not using fastsrb functions, redraw only when needed otherwise. No waiting loop. Count the number of
frames during 300 AI5 ticks.

/* X16 routines.

0* __regparm__ grayscale utilities, while rewriting them all into GNU as ASM.

0* optimize sprite routines:
    0* optimize Gray(Clip)(I)Sprite32_TRANB/TRANW_R the same way as 8 and 16.
    /* Fast non-clipped GrayISpriteX_Y_R.

/* Lines, triangles, circles, etc:
    0* FastTestLine.
    0* ClipAndDrawLine, with callback. Which simple and efficient algorithm ?
    0* reimplement DrawMultiLines, A_NORMAL, A_XOR and A_REVERSE modes; make DrawMultiHLines.
    /* clipped and non-clipped draw / fill circles.
    0* clipped and non-clipped draw / fill triangles -> "tri.c".
    Note: an algorithm for circles, triangles and lines could be: use the stack (max 2*128 bytes) to store endpoints, call
DrawMultiHLines.
    0* "Extremely Fast Line Algorithm" (EFLA) by Po-Han Lin: what does "Freely useable in non-commercial applications as
long as credits to Po-Han Lin and link to http://www.edepot.com is provided in source code AND CAN BE SEEN IN COMPILED
EXECUTABLE [emphasis mine]" mean exactly ? Anyway, while the C version of EFLA which calls a subroutine to plot a pixel is
faster than the C version of Bresenham, it's not sure that the ASM version of EFLA would be faster than the ASM version of
Bresenham.
    ?* Specialized versions of GrayFastDrawHLine_X (note: more or less done in modified Extreme Racing).

0* DrawPattern (Slimeball)

0* Optimize ScaleSpriteX (rewrite in assembly with a more efficient algorithm, keep data in a register as long as it's
possible). Started by Julien (his C routines are twice faster, but it seems that there's something wrong, as demo5 becomes
ugly).

0* Preshifted 8x8.

?* "FastCopyRectangle" MiG53 asked for.


/* Transition effects: waiting loops in most of them, one routine makes one effect + demo18. Unless otherwise noted,
modes are invert (B/W - gray), FOTB (B/W - gray), FOTW (B/W - gray), FI (B/W - gray). B/W routines: add "BW" in front of
name.
    /* l'effect qu'on a dans TI-Chess avant l'affichage du logo, extérieur vers intérieur (1) et inversement (2), vers
blanc ou vers noir, 160x100 et 240x128: "ZapMinimize"/"ZapMaximize". Reprendre le code de TI-Hex, en ajoutant un clin
d'oeil.
    0* rectangles outlined concentriques, B/W et couleurs COLOR_WHITE/LIGHTGRAY/DARKGRAY/BLACK, extérieur vers intérieur
et inversement, 160x100 et 240x128: "RectMinimize"/"RectMaximize".
    /* dissolve effect: modes habituels + effet de Ice Hockey 68k (doublebuffering, accès direct aux variables internes),
240x128 seulement. Distinguer (sauf l'effet de Ice Hockey 68k ?) des versions "Faster" et "Slower" en ASM ("Slower" ayant
une boucle d'attente).
    0* effet code-barres basé sur un LFSR, horizontal et vertical (8 bits), 160xn, 240xn (nmax=255):
"HLines/VLines160/240_R". Mettre un paramètre spécifiant la première colonne (le LFSR le permet a priori).
    /* spiral X8X8, CW et CCW, extérieur -> intérieur et inversement, début top left et top right.
      CWS2: sequence down - left - up - right, inner  -> outer pixels.
      CCWS1: sequence left - down - right - up, outer -> inner pixels.
      CCWS2: sequence down - right - up - left, inner -> outer pixels.
    /* classiques X8xn L -> R, R -> L, T -> B, B -> T, également en colonnes de 8 pixels. Augmenter légèrement wait, pour
voir si c'est moins moche.
    0* fire similaire à celui de Krypton I (probablement sprite-based et peut-être même tile-based) 240x128, B -> T,
T -> B, R -> L, L -> R. Celui de TICT est trop gros... squale92 ?
    /* AND, OR, XOR mask de 32 bits vers planes 160x100, 240x128: "AND/OR/XORPlane(s)WithMask160x100/240x128_R".
    0* Modification de l'effet "Arcs de cercle" ("Search").



Always check:
* __regparm__ should use only d0-d3/a0-a1, except in the tilemap engine.
* all parameters sprite, mask, maskval should be unsigned.
* all parameters plane should be void *.
* all constant parameters should be const...
