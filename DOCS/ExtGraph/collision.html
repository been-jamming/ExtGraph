<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML lang="en">
<HEAD>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<TITLE>Library ExtGraph Documentation</TITLE>
<STYLE TYPE="TEXT/CSS">
<!--
BODY {FONT-FAMILY: Verdana,Arial,Helvetica,Sans-Serif; BACKGROUND-COLOR: #FFFFFF; FONT-SIZE: 10pt}
TD {FONT-SIZE: 8pt}
H1 {FONT-SIZE: 18pt; COLOR: #000000}
.toptitle {FONT-SIZE: 23pt; COLOR: #0000A0}
H2 {FONT-SIZE: 16pt; COLOR: #000000}
H3 {FONT-SIZE: 10pt}
.subtitle {FONT-SIZE: 13pt; COLOR: #8000A0}
PRE {FONT-FAMILY: Courier New; FONT-SIZE: 9pt}
CODE {FONT-FAMILY: Courier New; FONT-SIZE: 9pt}
-->
</STYLE>
</HEAD>
<BODY BGCOLOR="#FFFFFF" TEXT="#000000" ALINK="#FF0000" VLINK="#0000FF">

<hr>
<a name="#collision"><h1>Collision Detection Functions and Macros</h1></a>
<hr>
<p>

<h3>BOUNDS_COLLIDE(x0,y0,x1,y1,w,h)</h3>
Checks if two rectangle areas of width <em>w</em> and height <em>h</em> starting at (<em>x0</em>,<em>y0</em>)
and (<em>x1</em>,<em>y1</em>) overlaps. Returns 0 if areas won't overlap.

<h3>BOUNDS_COLLIDE8(x0,y0,x1,y1)</h3>
Checks if two square areas of width 8 and height 8 starting at (<em>x0</em>,<em>y0</em>)
and (<em>x1</em>,<em>y1</em>) overlaps. Returns 0 if areas won't overlap.

<h3>BOUNDS_COLLIDE16(x0,y0,x1,y1)</h3>
Checks if two square areas of width 16 and height 16 starting at (<em>x0</em>,<em>y0</em>)
and (<em>x1</em>,<em>y1</em>) overlaps. Returns 0 if areas won't overlap.

<h3>BOUNDS_COLLIDE32(x0,y0,x1,y1)</h3>
Checks if two square areas of width 32 and height 32 starting at (<em>x0</em>,<em>y0</em>)
and (<em>x1</em>,<em>y1</em>) overlaps. Returns 0 if areas won't overlap.

<h3>short TestCollide8(short x0,short y0,short x1,short y1,short h,unsigned char* data0, unsigned char* data1);</h3>
<h3>short TestCollide8_R(register short x0 asm("%d0"),register short y0 asm("%d1"),register short x1 asm("%d2"),register short y1 asm("%d3"),short height,register unsigned char* data0 asm("%a0"),register unsigned char* data1 asm("%a1")) __attribute__((__stkparm__));</h3>
Checks if the content of two sprites of width 8 and height <em>h</em> starting at (<em>x0</em>,<em>y0</em>)
and (<em>x1</em>,<em>y1</em>) overlaps. Returns 0 if sprites won't overlap. In difference to the bounds checking
macros these functions tests the content of two sprites by shifting the content if necessary and "AND"-ing the
data together. If a set pixel overlaps (i.e. is set in both sprites) a collision is detected. This way you can
test irregulary shaped sprites for collision and not only rectangular ones. <em>data0</em> and <em>data1</em> are pointers
to the content of the two sprites. For grayscale sprites it is a good idea to use a special type of mask data for
<em>data0</em> and <em>data1</em> where every pixel is set which should be involved in testing. A simple way to
generate such a mask is to OR the data of the dark plane and the light plane together into one plane. If you use
such a mask you'll need to call TestCollide8 only once.

<h3>short TestCollide16(short x0,short y0,short x1,short y1,short h,unsigned short* data0, unsigned short* data1);</h3>
<h3>short TestCollide16_R(register short x0 asm("%d0"),register short y0 asm("%d1"),register short x1 asm("%d2"),register short y1 asm("%d3"),short height,register unsigned short* data0 asm("%a0"),register unsigned short* data1 asm("%a1")) __attribute__((__stkparm__));</h3>
Checks if the content of two sprites of width 16 and height <em>h</em> starting at (<em>x0</em>,<em>y0</em>)
and (<em>x1</em>,<em>y1</em>) overlaps. Returns 0 if sprites won't overlap. In difference to the bounds checking
macros these functions tests the content of two sprites by shifting the content if necessary and "AND"-ing the
data together. If a set pixel overlaps (i.e. is set in both sprites) a collision is detected. This way you can
test irregulary shaped sprites for collision and not only rectangular ones. <em>data0</em> and <em>data1</em> are pointers
to the content of the two sprites. For grayscale sprites it is a good idea to use a special type of mask data for
<em>data0</em> and <em>data1</em> where every pixel is set which should be involved in testing. A simple way to
generate such a mask is to OR the data of the dark plane and the light plane together into one plane. If you use
such a mask you'll need to call TestCollide16 only once.
</p>

</BODY>
</HTML>
