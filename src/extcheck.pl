#!/usr/bin/perl -W
# Some code generated by `find2perl . -iname "*.{c,h}"`
use strict;
use File::Find ();

# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

package main;
    my $sourcecode;
    my %funcs;
    my %indirecttests;

sub library {
    my $line;
    my @lines;
    my ($filename, $funcname);
    my $regex;
    
    if (($name !~ m@/_copie@) && ($name !~ m@Slower@)) { # Skip local backups of files and old routines.
        if ($name =~ m@(\C*?)\.(s|c)$@i) { # Select .s and .c files.

            @lines = split /\//, $1;
            $filename = $lines[$#lines];

            open(INFILE, '+<', $name) or die "Can't open $name: $!";
            read(INFILE, $sourcecode, -s INFILE);
            close INFILE;
            
            if ($name =~ m@\.s$@i) { # .s file
                @lines = split /\n/, $sourcecode;
                if ($lines[$#lines] ne "") {
                    push @lines, "";
                }

                # Does this file contains a mention of its C prototype ?
                if ($lines[0] =~ m@\|\sC\sprototype:\s(\C*?)\s(\S+)\s?\((\C+)$@) {
                    $funcname = $2;
                    if ($filename eq $funcname) {
                        # OK, this file seems to be named after the function it contains.
                        if (!defined($funcs{$funcname})) {
                            warn "File $name has a prototype for $funcname, but that function name was not found in the headers.\n";
                        }
                        else {
                            $lines[0] = "| C prototype: $funcs{$funcname}";

                            # While we're at it, check that this file contains an appropriate .globl
                            # declaration and an appropriate label.
                            # \n\C*?$funcname\:\n
                            
                            $regex = qr@(xdef|\.globl)\ $funcname\C*?$funcname\:@s;
                            if ($sourcecode !~ $regex) {
                                warn "WARNING: file $name doesn't contain a proper declaration of $funcname !\n";
                            }
                            open(OUTFILE, '+>', "$name") or die "Can't open $name: $!";
                            print OUTFILE join ("\n", @lines);
                            close OUTFILE;

                            delete $funcs{$funcname};
                        }
                    }
                    else {
                        warn "Mismatch between file name $name and embedded prototype for $funcname\n";
                    }
                }
                else {
                    if (!defined($funcs{$filename})) {
                        warn "File $name has no prototype for $filename, and that function name was not found in the headers.\n";
                    }
                    delete $funcs{$filename};
                }
            }
            else { # C file.
                $regex = qr@$filename@si;
                if ($sourcecode =~ $regex) {
                    if (!defined($funcs{$filename})) {
                        warn "WARNING: file $name contains string $filename, but no corresponding prototype found in the headers.\n";
                    }
                    else {
                        warn "File $name contains string $filename, check the prototype.\n";
                    }
                }
                else {
                    warn "WARNING: file $name doesn't seem to contain symbol $filename !\n";
                }
                # TODO: update prototypes within C files ?
                delete $funcs{$filename};
            }
        }
    }

}

sub demos {
    my @path;
    #my $foundsometests = 0;
    
    if ($name =~ m@(\C*?)\.(asm|c)$@i) { # Select .asm and .c files.
        open(INFILE, '+<', $name) or die "Can't open $name: $!";
        read(INFILE, $sourcecode, -s INFILE);
        close INFILE;
        
        @path = split /\//, $name;
        $name = $path[$#path];

        for my $key (keys %funcs) {
            if (   ($sourcecode =~ m@$key\s*\(@s)
                || ($sourcecode =~ m@,\s*$key@s)
               ) {
                #$foundsometests = 1;
                print "Found test for function $key in $name";
                if (defined($indirecttests{$key})) {
                    my $message = '';
                    my @indirecttests = $indirecttests{$key};
                    my $indirects = $indirecttests[0];
                    for my $indirect (@{$indirects}) {
                        if (defined($funcs{$indirect})) {
                            $message = $message . "$indirect ";
                        }
                        delete $funcs{$indirect};
                    }
                    if ($message ne '') {
                        print ", thereby indirect tests for ";
                    }
                    print $message;
                }
                print "\n";
                delete $funcs{$key};
                next;
            }
        }

        # The order in which the directory is traversed can trigger spurious warnings, e.g. demo10.
        #if ($foundsometests == 0) {
            #print "WARNING: found no tests in $name, check the script !\n";
        #}
    }
}

sub parseheader ($; $) {
    my $filename = shift;
    my $putindirecttests = shift;
    my $spuriousindex;
    my $funcname;
    my @indirecttests;
    
    open(INFILE, $filename) or die "Can't open $filename: $!";
    read(INFILE, $sourcecode, -s INFILE);
    close INFILE;
    # Select only the function prototypes defined in extgraph.h
    ($sourcecode =~ m@//\-\-BEGIN_FUNCTION_PROTOTYPES\-\-//(\C*?)//\-\-END_FUNCTION_PROTOTYPES\-\-//@gso) or die "Can't find necessary comments in extgraph.h\n";
    $sourcecode = $1;

    my @lines = split /\n/, $sourcecode;
    for my $line (@lines) {

        next if (   ($line =~ m@^\s?$@o)     # Empty line
                 || (index($line,'//') == 0) # Line starting with //
                 || (index($line,'/*') == 0) # Line starting with /*
                 || (index($line,' *') == 0) # Line starting with ' *'
                );
                
        if (index($line, '#') == 0) {
            if ((index($line, 'define Gray') == 1) || (index($line, 'define TM_') == 1)) {
                # This looks like a #define for a GrayUtil or a tilemap engine function.
                ($line =~ m@^#define ([^(\ ]+)\C+$@o) or die "Strange line \"$line\"\n";
                $funcname = $1;
            }
            else {
                next;
            }
        }
        else {
            ($line =~ m@^(\C*?)\s(\S+)\s?\((\C+)$@o) or die "Strange line \"$line\"\n";
            # Function $2 has (almost) prototype $line.
            $funcname = $2;
        }
            
        # Strip trailing Doxygen comment if any.
        $spuriousindex = index($line, " ///< ");
        if ($spuriousindex != -1) {
            $line = substr ($line, 0, $spuriousindex);
        }
        # Strip leading 'extern '
        $spuriousindex = index($line, "extern ");
        if (($spuriousindex != -1) && ($spuriousindex == 0)) {
            $line = substr ($line, length("extern "));
        }

        if ($line =~ m@^(\C*?)\ //\ --TESTS-(([^-]+,?)+)--$@o) {
            # This function is said to indirectly test at least another one.
            $line = $1;
            if ($putindirecttests != 0) {
                @indirecttests = split /\,/, $2;
                #print @indirecttests; print "\n";
                $indirecttests{$funcname} = [ @indirecttests ];
            }
        }

        $funcs{$funcname} = $line;
    }
}

    die "Usage: 'extcheck.pl (--fixproto|--coverage)'.\n" if $#ARGV != 0;
    
    
    if ($ARGV[0] eq '--fixproto') {
        # Read header files.
        parseheader "../lib/extgraph.h", 0;
        parseheader "../lib/tilemap.h", 0;
        parseheader "../lib/preshift.h", 0;

        # Traverse desired filesystem
        File::Find::find({wanted => \&library, no_chdir => 1}, './lib');

        for my $key (sort keys %funcs) {
            print "Found no implementation for function $key\n";
        }
    }
    elsif ($ARGV[0] eq '--coverage') {
        # Read header files.
        parseheader "../lib/extgraph.h", 1;
        parseheader "../lib/tilemap.h", 1; # TODO: improve script so that less false negatives are triggered by this one...
        parseheader "../lib/preshift.h", 1;

        # Traverse desired filesystem
        File::Find::find({wanted => \&demos, no_chdir => 1}, './demos');

        for my $key (sort keys %funcs) {
            if (index($key, 'TM_') != 0) {
                print "Found no test for function $key\n";
            }
        }
    }
