#!/usr/bin/perl -W
# Some code generated by `find2perl . -iname "*.{c,h}"`
use strict;
use File::Find ();

# for the convenience of &wanted calls, including -eval statements:
use vars qw/*name *dir *prune/;
*name   = *File::Find::name;
*dir    = *File::Find::dir;
*prune  = *File::Find::prune;

package main;
    my $sourcecode;
    my %funcs;

sub library {
    my $line;
    my @lines;
    my ($filename, $funcname);
    my $regex;
    
    if (($name !~ m@/_copie@) && ($name !~ m@Slower@)) { # Skip local backups of files and old routines.
        if ($name =~ m@(\C*?)\.(s|c)$@i) { # Select .s and .c files.

            @lines = split /\//, $1;
            $filename = $lines[$#lines];

            open(INFILE, '+<', $name) or die "Can't open $name: $!";
            read(INFILE, $sourcecode, -s INFILE);
            close INFILE;
            
            if ($name =~ m@\.s$@i) { # .s file
                @lines = split /\n/, $sourcecode;
                if ($lines[$#lines] ne "") {
                    push @lines, "";
                }

                # Does this file contains a mention of its C prototype ?
                if ($lines[0] =~ m@\|\sC\sprototype:\s(\C*?)\s(\S+)\s?\((\C+)$@) {
                    $funcname = $2;
                    if (lc($filename) eq lc($funcname)) {
                        # OK, this file seems to be named after the function it contains.
                        if (!defined($funcs{$funcname})) {
                            warn "File $name has a prototype for $funcname, but that function name was not found in the headers.\n";
                        }
                        else {
                            $lines[0] = "| C prototype: $funcs{$funcname}";

                            # While we're at it, check that this file contains an appropriate .globl
                            # declaration and an appropriate label.
                            # \n\C*?$funcname\:\n
                            
                            $regex = qr@(xdef|\.globl)\ $funcname\C*?$funcname\:@s;
                            if ($sourcecode !~ $regex) {
                                warn "WARNING: file $name doesn't contain a proper declaration of $funcname !\n";
                            }
                            open(OUTFILE, '+>', "$name") or die "Can't open $name: $!";
                            print OUTFILE join ("\n", @lines);
                            close OUTFILE;

                            delete $funcs{$funcname};
                            delete $funcs{lc($funcname)};
                        }
                    }
                    else {
                        warn "Mismatch between file name $name and embedded prototype for $funcname\n";
                    }
                }
                else {
                    if (!defined($funcs{lc($filename)})) {
                        warn "File $name has no prototype for $filename, and that function name was not found in the headers.\n";
                    }
                    delete $funcs{$filename};
                    delete $funcs{lc($filename)};
                }
            }
            else { # C file.
                $regex = qr@$filename@si;
                if ($sourcecode =~ $regex) {
                    if (!defined($funcs{lc($filename)})) {
                        warn "WARNING: file $name contains string $filename, but no corresponding prototype found in the headers.\n";
                    }
                    else {
                        warn "File $name contains string $filename, check the prototype.\n";
                    }
                }
                else {
                    warn "WARNING: file $name doesn't seem to contain symbol $filename !\n";
                }
                # TODO: update prototypes within C files ?
                delete $funcs{$filename};
                delete $funcs{lc($filename)};
            }
        }
    }

}

sub demos {
    my $regex;
    my @path;
    #my $foundsometests = 0;
    
    if ($name =~ m@(\C*?)\.(asm|c)$@i) { # Select .asm and .c files.
        open(INFILE, '+<', $name) or die "Can't open $name: $!";
        read(INFILE, $sourcecode, -s INFILE);
        close INFILE;
        
        @path = split /\//, $name;
        $name = $path[$#path];

        for my $key (keys %funcs) {
            $regex = qr@$key\s*\(@s; # funcname (
            if ($sourcecode =~ $regex) {
                #$foundsometests = 1;
                print "Found test for function $key in $name\n";
                delete $funcs{$key};
                delete $funcs{lc($key)};
                next;
            }
            $regex = qr@,\s*$key@s; # , funcname (as callback)
            if ($sourcecode =~ $regex) {
                print "Found test for function $key in $name\n";
                delete $funcs{$key};
                delete $funcs{lc($key)};
                next;
            }
        }

        # The order in which the directory is traversed can trigger spurious warnings, e.g. demo10.
        #if ($foundsometests == 0) {
            #print "WARNING: found no tests in $name, check the script !\n";
        #}
    }
}

sub parseheader ($; $) {
    my $filename = shift;
    my $putlowercase = shift;
    my $spuriousindex;
    
    open(INFILE, $filename) or die "Can't open $filename: $!";
    read(INFILE, $sourcecode, -s INFILE);
    close INFILE;
    # Select only the function prototypes defined in extgraph.h
    ($sourcecode =~ m@//\-\-BEGIN_FUNCTION_PROTOTYPES\-\-//(\C*?)//\-\-END_FUNCTION_PROTOTYPES\-\-//@gso) or die "Can't find necessary comments in extgraph.h\n";
    $sourcecode = $1;

    my @lines = split /\n/, $sourcecode;
    for my $line (@lines) {

        # TODO improve the script so that it can understand the Grayutils aliases.

        next if (   ($line =~ m@^\s?$@o) # Empty line
                 || ($line =~ m@^\#@o) # Line starting with #
                 || ($line =~ m@^//@o) # Line starting with //
                 || ($line =~ m@^/\*@o) # Line starting with /*
                 || ($line =~ m@^\ \*@o) # Line starting with ' *'
                );
        
        ($line =~ m@^(\C*?)\s(\S+)\s?\((\C+)$@o) or die "Strange line \"$line\"\n";
        # Function $2 has (almost) prototype $line.
        
        # Strip trailing Doxygen comment if any.
        $spuriousindex = index($line, " ///< ");
        if ($spuriousindex != -1) {
            $line = substr ($line, 0, $spuriousindex);
        }
        
        $spuriousindex = index($line, "extern ");
        if ($spuriousindex != -1) {
            $line = substr ($line, length("extern "));
        }
        
        $funcs{$2} = $line;
        if ($putlowercase != 0) {
            $funcs{lc($2)} = $line;
        }
    }
}

    die "Usage: 'extcheck.pl (--fixproto|--coverage)'.\n" if $#ARGV != 0;
    
    
    if ($ARGV[0] eq '--fixproto') {
        # Read header files.
        parseheader "../lib/extgraph.h", 1;
        parseheader "../lib/tilemap.h", 1;
        parseheader "../lib/preshift.h", 1;

        # Traverse desired filesystem
        File::Find::find({wanted => \&library, no_chdir => 1}, './lib');

        for my $key (sort keys %funcs) {
            print "Found no implementation for function $key\n";
        }
    }
    elsif ($ARGV[0] eq '--coverage') {
        # Read header files.
        parseheader "../lib/extgraph.h", 0;
        parseheader "../lib/tilemap.h", 0; # TODO: improve script so that slightly less false positives are triggered by this one...
        parseheader "../lib/preshift.h", 0;

        # Traverse desired filesystem
        File::Find::find({wanted => \&demos, no_chdir => 1}, './demos');

        for my $key (sort keys %funcs) {
            print "Found no test for function $key\n";
        }
    }
